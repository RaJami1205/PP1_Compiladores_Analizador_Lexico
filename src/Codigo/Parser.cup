package ParserLexer;
import java_cup.runtime.*;
 action code {:
 
    public void hola(){
        System.out.println("hola.");
    }
 
    public void adios(){
        System.out.println("adios");
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

:}
 
init with {: :};
 
/* define how to connect to the scanner! */
scan with {: return lex.next_token(); :}

/* Definición de los terminales */
terminal LET, PROCEDURE ,PRINCIPAL, FUNCTION, INT, FLOAT, CHAR, BOOL, DECIDE
,OF, ELSE, END, LOOP, EXIT, WHEN, FOR, STEP, TO, DOWNTO, DO, RETURN, BREAK,
INPUT, OUTPUT, ASSIGN, LT, LE, GT, GE, EQ, NE, PLUS,
MINUS, MULT, DIV, INT_DIV, MOD, POW, AND, OR, SIGMA, INCREMENT, DECREMENT, OPEN_PAREN,
CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE, OPEN_BRACKET, CLOSE_BRACKET, COLON, COMMA,
ARROW, SEMICOLON;

/* Símbolos especiales */
    "є"                { return symbol(sym.OPEN_PAREN); }
    "э"                { return symbol(sym.CLOSE_PAREN); }
    "¿"                { return symbol(sym.OPEN_BRACE); }
    "?"                { return symbol(sym.CLOSE_BRACE); }
    "["                { return symbol(sym.OPEN_BRACKET); }
    "]"                { return symbol(sym.CLOSE_BRACKET); }
    ":"                { return symbol(sym.COLON); }
    ","                { return symbol(sym.COMMA); }
    "->"               { return symbol(sym.ARROW); }
    "$"                { return symbol(sym.SEMICOLON); }

 

/* Definición de los no terminales */
non terminal programa, decl_glob, decl_var, funcion, param_formales_opt,
 param, tipo_ret, tipo, tipo_arreglo, tam_arreglo, bloque, sentencia,
 sent_decl_local, sent_asig_o_expr, sent_decide, sent_loop, sent_for,
 sent_return, sent_break, sent_io, comentario, comentario_linea,
 comentario_multilinea, sent_decl_local, decl_var, init_opt, init_arr_opt,
 asignacion, lvalue, expr_sin_asignacion, sent_decide, sent_loop, sent_for,
 sent_return, sent_break, sent_io, lista_out, expr, expr_log_or, expr_log_and,
 expr_rel, op_rel, expr_aditiva, expr_mult, expr_pot, expr_unaria, op_unario,
 expr_postfijo, postfix_op, primario, llamada_func, lista_args_opt, lista_args,
 cond_bool, lit, lit_entero, lit_flotante, lit_bool, lit_char, lit_string,
 lit_arreglo, lit_entero, lit_flotante, lit_bool, lit_char, lit_string,
 lit_arreglo, lit_entero, lit_flotante, lit_bool, lit_char, lit_string,
 lit_arreglo, signo_opt;

start with program;

control::=  for_B | while_B | doWhile_B | optn ;

expr ::= exprUni | asignacionUni | read | write | return_A | control;
bloque ::= expr | bloque expr ;

params ::= PARENTESIS_I creacion  PARENTESIS_D ;


funcMain ::= tipoFunc IDENTIFICADOR params FINLINEA
            | tipoFunc IDENTIFICADOR params  LLAVE_ABIERTO_T bloque LLAVE_CERRADO_T;
dec ::= funcMain ; 

decS ::= dec
        | decS dec;

inicio ::= decS;

programa ::= inicio ;

programa ::= <decl_glob>* <funcion>* <principal>
decl_glob ::= "let" <decl_var> "$"
principal ::= "procedure" "principal" "є" "э" <bloque> /* void, sin parámetros */
funcion ::= "function" <id> "є" <param_formales_opt> "э" ":" <tipo_ret>
 <bloque>
<param_formales_opt> ::= /* vacío */
 | <lista_params>
<lista_params> ::= <param> ("," <param>)*
<param> ::= <id> ":" <tipo>
<tipo_ret> ::= "int" | "float" | "char" | "bool"
<tipo> ::= "int"
 | "float"
 | "char"
 | "bool"
 | <tipo_arreglo>
<tipo_arreglo> ::= "int" "[" <tam_arreglo> "]"
 | "char" "[" <tam_arreglo> "]"
<tam_arreglo> ::= <lit_entero> /* tamaño estático, positivo */
/* ===================== BLOQUES Y SENTENCIAS ===================== */
<bloque> ::= "¿" <sentencia>* "?"
 | <sentencia> /* bloque reducido: una sola sentencia */
<sentencia> ::= <sent_decl_local>
 | <sent_asig_o_expr>
 | <sent_decide>
 | <sent_loop>
 | <sent_for>
 | <sent_return>
 | <sent_break>
 | <sent_io>
 | <comentario> /* comentarios como sentencia (se ignoran) */
<comentario> ::= <comentario_linea> | <comentario_multilinea>
<comentario_linea> ::= "|" <caracter>* <fin_linea>
<comentario_multilinea> ::= "¡" <caracter_comentario>* "!"
<sent_decl_local> ::= "let" <decl_var> "$"
<decl_var> ::= <id> ":" <tipo> <init_opt>
 | <id> ":" <tipo_arreglo> <init_arr_opt>
<init_opt> ::= /* vacío */
 | "=" <expr>
<init_arr_opt> ::= /* vacío */
 | "=" <lit_arreglo> /* creación con asignación */
<asignacion> ::= <lvalue> "=" <expr>
<lvalue> ::= <id>
 | <id> "[" <expr> "]" /* acceso/modificación de arreglo */
<expr_sin_asignacion> ::= <expr> /* expresiones permitidas como sentencia */
/* ===================== ESTRUCTURAS DE CONTROL ====================*/
<sent_decide> ::= "decide" "of"
 ( "є" <cond_bool> "э" "->" <bloque> )+
 ( "else" "->" <bloque> )?
 "end" "decide" "$"
<sent_loop> ::= "loop"
 <sentencia>*
 "exit" "when" <cond_bool> "$"
 "end" "loop" "$"
<sent_for> ::= "for" <asignacion> "step" <valor_step>
 ( "to" | "downto" ) <expr> "do"
 <bloque>
<valor_step> ::= <lit_entero> | <lit_flotante>
/* ===================== RETURN / BREAK ===================== */
<sent_return> ::= "return" <expr> "$"
 | "return" "$" /* en funciones void NO se usa; sólo por flexibilidad */
<sent_break> ::= "break" "$"
/* ===================== I/O ===================== */
<sent_io> ::= "input" "є" <id> "э" "$" /* lee a variable int o float */
 | "output" "є" <lista_out> "э" "$"
<lista_out> ::= <expr> ("," <expr>)* /* literales o variables de tipo permitido */
/* ===================== EXPRESIONES ===================== */
<expr> ::= <expr_log_or>
<expr_log_or> ::= <expr_log_and> ( "~" <expr_log_and> )*
<expr_log_and> ::= <expr_rel> ( "@" <expr_rel> )*
<expr_rel> ::= <expr_aditiva>
 | <expr_aditiva> <op_rel> <expr_aditiva>
<op_rel> ::= "<" | "<=" | ">" | ">=" | "==" | "!="
<expr_aditiva> ::= <expr_mult> ( ("+" | "-") <expr_mult> )*
<expr_mult> ::= <expr_pot> ( ("*" | "/" | "//" | "%") <expr_pot> )*
<expr_pot> ::= <expr_unaria> ( "^" <expr_unaria> )*
<expr_unaria> ::= <op_unario> <expr_unaria>
 | <expr_postfijo>
<op_unario> ::= "-" | "Σ"
<expr_postfijo> ::= <primario> ( <postfix_op> )*
<postfix_op> ::= "++" | "--" | "[" <expr> "]"
<primario> ::= <lit>
 | <lvalue>
 | <llamada_func>
 | "є" <expr> "э"
<llamada_func> ::= <id> "є" <lista_args_opt> "э"
<lista_args_opt> ::= /* vacío */
 | <lista_args>
<lista_args> ::= <expr> ("," <expr>)*
<cond_bool> ::= <expr> /* debe tipar a boolean en control de flujo */
/* ===================== LITERALES ===================== */
<lit> ::= <lit_entero>
 | <lit_flotante>
 | <lit_bool>
 | <lit_char>
 | <lit_string>
 | <lit_arreglo>
<lit_entero> ::= <signo_opt> <digito>+
<lit_flotante> ::= <signo_opt> <digito>+ "." <digito>+
<lit_bool> ::= "true" | "false"
<lit_char> ::= "'" <caracter> "'"
<lit_string> ::= "\"" <caracter_string>* "\""
<lit_arreglo> ::= "¿" <lista_elem_arr_opt> "?"
<lista_elem_arr_opt> ::= /* vacío */
 | <lista_elem_arr>
<lista_elem_arr> ::= <expr> ("," <expr>)*
<signo_opt> ::= /* vacío */ | "-"