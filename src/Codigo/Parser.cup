package ParserLexer;

import java_cup.runtime.*;
import Compilador.MySymbol;
import Compilador.SymbolTable;
import Compilador.IntermediateCode;
import Compilador.GenerateTemp;
import Compilador.GenerateLabel;
import java.util.List;
import java.util.ArrayList;


parser code {:
    
    Lexer lex;
    public static java.util.List<String> errores = new java.util.ArrayList<>();
    public static SymbolTable tablaSimbolos = new SymbolTable();
    public static IntermediateCode codigoIntermedio = new IntermediateCode();
    GenerateTemp genTemp = new GenerateTemp();
    GenerateLabel genLabel = new GenerateLabel();
    private static String[] decideLabels = null;
    private static String[] parserLoopLabels = null;

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    public void report_error(String message, Object info) {
        errores.add("Error sintáctico: " + message + " en " + info);
        System.err.println("Error sintáctico: " + message + " en " + info);
    }

    public void syntax_error(Symbol cur_token) {
        Object value = cur_token.value;
        int left = cur_token.left;
        int right = cur_token.right;
        errores.add("Token inesperado '" + value + 
                    "' en línea " + (left + 1) + 
                    ", columna " + (right + 1));
        System.err.println("Token inesperado '" + value + 
                        "' en línea " + (left + 1) + 
                        ", columna " + (right + 1));
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        Object value = cur_token.value;
        errores.add("Error no recuperable: " + value);
        System.err.println("Error no recuperable: " + value);
    }

    private String inferTypeOfOperand(String op) {
        if (op == null) return "int";

        op = op.trim();

        System.out.println("Operando: " + op);

        if (op.equalsIgnoreCase("true") || op.equalsIgnoreCase("false")) {
            return "bool";
        }

        if (op.length() == 3 && op.startsWith("'") && op.endsWith("'")) {
            return "char";
        }

        if (op.length() >= 2 && op.startsWith("'") && op.endsWith("'")) {
            return "string";
        }

        try {
            Integer.parseInt(op);
            return "int";
        } catch (NumberFormatException e) {}

        try {
            Double.parseDouble(op);
            if (op.contains(".")) return "float";
            return "int";
        } catch (NumberFormatException e) {}

        MySymbol s = tablaSimbolos.getSymbol(op);
        if (s != null && s.getType() != null) {
            return s.getType();
        }


        return "int";
    }

    private MySymbol createTempFor(String type) {
        String t = GenerateTemp.newTemp();
        // guardar en tabla (en alcance actual)
        tablaSimbolos.addSymbol(t, type, "temp", null);
        MySymbol tempSym = tablaSimbolos.getSymbol(t);
        if (tempSym != null) {
            tempSym.setAddress(t);
            tempSym.setTemporary(true);
        }
        return tempSym;
    }

    private boolean tiposCompatibles(String tipoDestino, String tipoFuente) {
    if (tipoDestino == null || tipoFuente == null) return true; // evitar errores en nulos

    // Normalizar a minúsculas
    tipoDestino = tipoDestino.toLowerCase();
    tipoFuente = tipoFuente.toLowerCase();

    // Mismos tipos siempre compatibles
    if (tipoDestino.equals(tipoFuente)) return true;

    // Compatibilidades numéricas (ej: int = float es válido)
    if ((tipoDestino.equals("float") && tipoFuente.equals("int")) ||
        (tipoDestino.equals("int") && tipoFuente.equals("float"))) {
        return true;
    }

    // No se permiten asignaciones de bool, char o string a int o float
    if (tipoDestino.equals("bool") || tipoDestino.equals("char") || tipoDestino.equals("string"))
        return tipoDestino.equals(tipoFuente);

    // Si nada coincide
    return false;
}
:}

init with {: :};

 scan with {: return lex.next_token(); :}

/* Definición de los terminales */

terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Float FLOAT_LITERAL;
terminal Character CHAR_LITERAL;
terminal String STRING_LITERAL;
terminal Boolean TRUE, FALSE;

terminal String INT, FLOAT, CHAR, BOOL, STRING;

terminal 
    LET, PROCEDURE, PRINCIPAL,
    DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, STEP, TO, DOWNTO, DO,
    RETURN, BREAK, INPUT, OUTPUT,
    ASSIGN, LT, LE, GT, GE, EQ, NE, PLUS, MINUS, MULT, DIV, INT_DIV, MOD, POW,
    AND, OR, SIGMA, INCREMENT, DECREMENT,
    OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
    OPEN_BRACKET, CLOSE_BRACKET, COLON, COMMA, ARROW, SEMICOLON, COMMENT_LINE, COMMENT_MULTI;


/* Definición de los no terminales */
non terminal 
    programa, decl_glob, decl_var, funcion, principal, 
    param_formales_opt, lista_params, param, tipo_ret, tipo, tipo_arreglo,
    bloque, sentencia, sent_decl_local, sent_asig_o_expr, sent_decide, sent_loop, sent_for,
    sent_return, sent_break, sent_io, comentario, comentario_linea, comentario_multilinea,
    init_opt, asignacion, lvalue, expr_sin_asignacion, lista_out,
    expr_log_or, expr_log_and, expr_rel, op_rel, expr_aditiva, expr_mult, expr_pot, expr_unaria,
    op_unario, expr_postfijo, postfix_op, primario, llamada_func, lista_args_opt, lista_args,
    cond_bool, lit, lista_elem_arr_opt, lista_elem_arr, valor_step,sent_loop_rec,for_dir,sent_decide_rec,
    lit_arreglo,lista_decl,decl,lista_sentencias_opt,lista_sentencias,decl_var_simple,
    init_arr_opt,lvalue_aux,sign,literal_numerico;

non terminal Object decl_var_arreglo;
non terminal Object tam_arreglo;
non terminal Object expr;

precedence left OR;
precedence left AND;
precedence nonassoc LT, LE, GT, GE, EQ, NE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, INT_DIV, MOD;
precedence right POW;
precedence right SIGMA; 



start with programa;

programa ::= lista_decl;

lista_decl ::= lista_decl decl | decl;

decl ::= decl_glob | funcion | principal ; 

decl_glob ::= LET decl_var SEMICOLON ;

principal ::= PROCEDURE PRINCIPAL OPEN_PAREN CLOSE_PAREN  
    {: 
        if (!tablaSimbolos.addSymbol("principal", "void", "procedure", null)) {
                System.err.println("Error: El procedimiento principal ya esta declarado.");
        } else {
                System.out.println("Procedimiento principal agregado a la tabla de símbolos (tipo void).");
        }

        System.out.println(">> Entrando a ámbito del procedimiento principal");

    :}
    bloque
    {:
        System.out.println("<< Saliendo del ámbito del procedimiento principal");
    :};
 
funcion ::=
    tipo_ret:ret IDENTIFIER:id
    {:
        String nombre = (String) id;  
        String tipoRet = (String) ret;

        if (!tablaSimbolos.addSymbol(nombre, tipoRet, "function", null)) {
            System.err.println("Error semántico: función duplicada " + nombre);
        } else {
            Compilador.MySymbol s = tablaSimbolos.getSymbol(nombre);
            s.setReturnType(tipoRet);
            System.out.println("Función agregada: " + s);
        }

        System.out.println(">> Entrando a ámbito de función " + nombre);
    :}
    OPEN_PAREN param_formales_opt CLOSE_PAREN
    bloque
    {:
        System.out.println("<< Saliendo de ámbito de función " + id);
    :};
            
param_formales_opt ::= /* vacío */ | lista_params ; 

lista_params ::= lista_params COMMA param | param;

param ::= IDENTIFIER:id COLON tipo:tipoParam
        {:
            if(!tablaSimbolos.addSymbol((String)id,(String)tipoParam,"param",null))
            {
                System.out.println("YA EXISTE PARAMETRO CON ESE NOMBRE");
        
            };
        :}
 ;

tipo_ret ::= INT   {: RESULT = "int"; :}
            | FLOAT {: RESULT = "float"; :}
            | CHAR  {: RESULT = "char"; :}
            | BOOL  {: RESULT = "bool"; :}
            | STRING {: RESULT = "string"; :}
            ;

tipo ::= INT   {: RESULT = "int"; :}
       | FLOAT {: RESULT = "float"; :}
       | CHAR  {: RESULT = "char"; :}
       | BOOL  {: RESULT = "bool"; :}
       | STRING {: RESULT = "string"; :}
       ;
                


/* ===================== BLOQUES Y SENTENCIAS ===================== */


bloque ::=
    OPEN_BRACE
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a nuevo ámbito (bloque)");
    :}
    lista_sentencias_opt
    CLOSE_BRACE
    {:
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ámbito (bloque)");
    :};

lista_sentencias_opt ::= /* vacío */ | lista_sentencias ;

lista_sentencias ::= lista_sentencias sentencia | sentencia ; 

sentencia ::= sent_decl_local
            | sent_asig_o_expr
            | sent_decide
            | sent_loop
            | sent_for
            | sent_return
            | sent_break
            | sent_io
            | comentario 
            ;

sent_decl_local ::= LET decl_var SEMICOLON;

decl_var ::= decl_var_simple | decl_var_arreglo;

decl_var_simple ::= tipo:tipo IDENTIFIER:id init_opt:valorInit {:
    String nombre = (String) id;       
    String tipoVar = (String) tipo;    
    Object valor = valorInit;

    String tipoValor = null;
    if (valor != null) {
        tipoValor = inferTypeOfOperand(valor.toString());

        if (!tiposCompatibles(tipoVar, tipoValor)) {
            String msg = "Error semántico: tipo incompatible en '" + nombre + 
                         "'. Esperado " + tipoVar + " pero se encontró " + tipoValor;
            System.err.println(msg);
            errores.add(msg);
        }
    }

    if (!tablaSimbolos.addSymbol(nombre, tipoVar, "variable", valor)) {
        System.err.println("Error semántico: variable " + nombre + " ya declarada.");
    } else {
        Compilador.MySymbol s = tablaSimbolos.getSymbol((String) id);
        s.setAddress(nombre);  
        s.setOffset(0);       
        System.out.println("Variable agregada: " + s);

        codigoIntermedio.add("DECLARE", tipoVar,null,nombre);

         if (valor != null) {
            codigoIntermedio.add("=", valor.toString(), null, nombre);
        }
    }
    RESULT = nombre;
:};


decl_var_arreglo ::= tipo:tipo IDENTIFIER:id OPEN_BRACKET tam_arreglo:size CLOSE_BRACKET init_arr_opt:init {:
    String nombre = (String) id;
    String tipoBase = (String) tipo;
    String tamanio = (size != null) ? String.valueOf(size) : null;
    Object inicializacion = init;

    // Primero agregamos el símbolo del arreglo
    if (!tablaSimbolos.addSymbol(nombre, tipoBase + "[]", "arreglo", null)) {
        System.err.println("Error semántico: el arreglo " + nombre + " ya fue declarado.");
    } else {
        Compilador.MySymbol s = tablaSimbolos.getSymbol(nombre);
        s.setAddress(nombre);
        s.setOffset(0);

        // Validar tamaño 
        String tipoTam = inferTypeOfOperand(tamanio);
        if (!tipoTam.equals("int")) {
            String msg = "Error semántico: el tamaño del arreglo '" + nombre + "' debe ser entero, no " + tipoTam;
            System.err.println(msg);
            errores.add(msg);
            s.setArraySize(0);
        } else {
            try {
                s.setArraySize(Integer.parseInt(tamanio));
            } catch (NumberFormatException ex) {
                String msg = "Error semántico: el tamaño del arreglo '" + nombre + "' debe ser un valor entero literal, no una variable o expresión.";
                System.err.println(msg);
                errores.add(msg);
                s.setArraySize(0);
            }
        }

        System.out.println("Arreglo agregado: " + s);

        // Código intermedio: declarar arreglo
        codigoIntermedio.add("DECLARE_ARRAY", tipoBase, tamanio, nombre);

        // Si hay inicialización
        if (inicializacion != null) {
            List<String> valores = (List<String>) inicializacion;

            if (valores.size() > s.getArraySize()) {
                String msg = "Error semántico: demasiados valores en la inicialización del arreglo '" + nombre + "'";
                System.err.println(msg);
                errores.add(msg);
            }

            int index = 0;
            for (String v : valores) {
                String tipoValor = inferTypeOfOperand(v);
                if (!tiposCompatibles(tipoBase, tipoValor)) {
                    String msg = "Error semántico: tipo incompatible en arreglo '" + nombre +
                                 "' en índice " + index + ": esperado " + tipoBase + " pero encontrado " + tipoValor;
                    System.err.println(msg);
                    errores.add(msg);
                } else {
                    // Generar asignación ARR_STORE
                    String tempIndex = codigoIntermedio.newTemp();
                    codigoIntermedio.add("=", String.valueOf(index), null, tempIndex);
                    codigoIntermedio.add("ARR_STORE", nombre, tempIndex, v);
                }
                index++;
            }
        }
    }

    RESULT = nombre;
:};

tam_arreglo ::= expr;

init_opt ::=
    /* vacío */ 
        {: RESULT = null; :}
  | ASSIGN expr:valor
        {: RESULT = valor; :};

init_arr_opt ::=   /*vacio*/ | ASSIGN lit_arreglo;
 

asignacion ::= lvalue:id ASSIGN expr:valor 
    {:
        String dest = (String) id;
        String src = (String) valor;

        MySymbol varDest = tablaSimbolos.getSymbol(dest);
        if (varDest == null) {
            String msg = "Error semántico: variable no declarada '" + dest + "'";
            System.err.println(msg);
            errores.add(msg);
        } else {
            String tipoDest = varDest.getType();
            String tipoSrc = inferTypeOfOperand(src);

            if (!tiposCompatibles(tipoDest, tipoSrc)) {
                String msg = "Error semántico: tipos incompatibles en asignación '" +
                             dest + " = " + src + "' (" + tipoDest + " ← " + tipoSrc + ")";
                System.err.println(msg);
                errores.add(msg);
            }
        }

        // generar cuadruplo de asignación
        codigoIntermedio.add("=", src, null, dest);
        tablaSimbolos.updateValue(dest, src);
        System.out.println("Asignación: " + dest + " = " + src);
        RESULT = dest;
    :};



lvalue ::= IDENTIFIER:id lvalue_aux:aux 
            {: 
                if (aux == null) {
                    RESULT = id;
                } else {
                    RESULT = id + aux;
                }
            :};

lvalue_aux ::= /* vacio */ {: RESULT = null; :}
             | OPEN_BRACKET expr:e CLOSE_BRACKET {: RESULT = "[" + e + "]"; :}
             ;


expr_sin_asignacion ::= expr ;

sent_asig_o_expr ::= asignacion SEMICOLON
                  | expr_sin_asignacion SEMICOLON;

/* ===================== ESTRUCTURAS DE CONTROL ====================*/

sent_decide ::=
    DECIDE OF OPEN_PAREN cond_bool:cond CLOSE_PAREN ARROW
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ámbito DECIDE");

        // Crear nuevas etiquetas
        String Lfalse = GenerateLabel.newLabel();
        String Lend = GenerateLabel.newLabel();

        // Guardar globalmente para uso del else
        decideLabels = new String[]{Lfalse, Lend};

        // Generar salto condicional: si cond es falso, ir a Lfalse
        codigoIntermedio.add("IF_FALSE", (String)cond, null, Lfalse);
    :}
    bloque:bloqueTrue sent_decide_rec
    END DECIDE SEMICOLON
    {:
        if (decideLabels != null) {
            String Lend = decideLabels[1];
            // Colocar etiqueta final
            codigoIntermedio.add("LABEL", Lend, null, null);
            decideLabels = null; // limpiar después del decide
        }

        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ámbito DECIDE");
    :};

sent_decide_rec ::=
      ELSE ARROW bloque:bloqueFalse
      {:
          if (decideLabels == null) {
              System.err.println("Error interno: decideLabels es null en ELSE");
          } else {
              String Lfalse = decideLabels[0];
              String Lend = decideLabels[1];

              // Salto incondicional al final del decide (después del bloque true)
              codigoIntermedio.add("GOTO", null, null, Lend);

              // Etiqueta del bloque else
              codigoIntermedio.add("LABEL", Lfalse, null, null);
          }
      :}
    | /* vacío */
      {:
          // Sin bloque else
      :};

sent_loop ::= 
    LOOP
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ámbito LOOP");

        // Crear etiquetas de inicio y salida del bucle
        String startLabel = GenerateLabel.newLabel();
        String exitLabel = GenerateLabel.newLabel();

        // Guardar en símbolos globales para usar con "exit when"
        parserLoopLabels = new String[]{startLabel, exitLabel};

        // Emitir etiqueta de inicio
        codigoIntermedio.add("LABEL", startLabel, null, null);
    :}
    sent_loop_rec
    EXIT WHEN cond_bool:cond SEMICOLON
    {:
        // Obtener etiquetas del bucle
        String[] labels = parserLoopLabels;
        if (labels != null) {
            String exitLabel = labels[1];
            // Generar salto condicional de salida
            codigoIntermedio.add("IF_TRUE", (String)cond, null, exitLabel);
        } else {
            System.err.println("Error interno: etiquetas del bucle no inicializadas.");
        }
    :}
    END LOOP SEMICOLON
    {:
        // Obtener etiquetas del bucle
        String[] labels = parserLoopLabels;
        if (labels != null) {
            String startLabel = labels[0];
            String exitLabel = labels[1];

            // Volver al inicio del bucle
            codigoIntermedio.add("GOTO", null, null, startLabel);

            // Emitir etiqueta de salida
            codigoIntermedio.add("LABEL", exitLabel, null, null);
        }

        parserLoopLabels = null;
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ámbito LOOP");
    :};


sent_loop_rec ::= sentencia sent_loop_rec | /* vacío */ ;

sent_for ::= 
    FOR 
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ambito FOR");
    :}
    decl_var_simple:init STEP valor_step:step for_dir:dir expr:limit DO bloque:body
    {:
        String var = (String) init;
        String paso = (String) step;
        String limite = (String) limit;

        String Linicio = codigoIntermedio.newLabel();
        String Lfin = codigoIntermedio.newLabel();

        codigoIntermedio.add("LABEL",null,null, Linicio);
        
        String tempCond = codigoIntermedio.newTemp();

        if (dir.equals("TO")){
            codigoIntermedio.add(">",var,limite,tempCond);
            codigoIntermedio.add("IF_TRUE",tempCond,null, Lfin);

            codigoIntermedio.add("+",var,paso,var);
        }
        else{
            // DOWNTO
            codigoIntermedio.add("<",var,limite,tempCond);
            codigoIntermedio.add("IF_TRUE",tempCond,null,Lfin);
            
            codigoIntermedio.add("-",var,paso,var);

        }

        codigoIntermedio.add("GOTO",null,null,Linicio);

        codigoIntermedio.add("LABEL",null,null,Lfin);

        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ambito FOR");
    :};


for_dir ::= TO {:RESULT = "TO";:} | DOWNTO {:RESULT = "DOWNTO";:};

valor_step ::= expr;


/* ===================== RETURN / BREAK ===================== */

sent_return ::= RETURN expr:val SEMICOLON
  {:
      codigoIntermedio.add("RETURN", (String)val, null, null);
      System.out.println("RETURN -> " + val);
  :}
  | RETURN SEMICOLON
  {:
      codigoIntermedio.add("RETURN", null, null, null);
      System.out.println("RETURN sin valor");
  :};

sent_break ::= BREAK SEMICOLON ;

/* ===================== I/O ===================== */

sent_io ::=
      OUTPUT OPEN_PAREN lista_out:arg CLOSE_PAREN SEMICOLON
      {:
          // Generar cuádruplo de impresión
          codigoIntermedio.add("PRINT", (String)arg, null, null);
          System.out.println("OUTPUT -> " + arg);
      :}
    | INPUT OPEN_PAREN IDENTIFIER:id CLOSE_PAREN SEMICOLON
      {:
          String varName = (String) id;
          Compilador.MySymbol sym = tablaSimbolos.getSymbol(varName);
          if (sym == null) {
              String msg = "Error semántico: variable no declarada '" + varName + "' en INPUT.";
              errores.add(msg);
              System.err.println(msg);
          } else {
              // Generar cuádruplo de lectura
              codigoIntermedio.add("READ", null, null, varName);
              System.out.println("INPUT -> " + varName);
          }
      :};

lista_out ::=
      lista_out:prev COMMA expr:val
        {: RESULT = prev + ", " + (String)val; :}
    | expr:val
        {: RESULT = (String)val; :};

/* ===================== EXPRESIONES ===================== */

expr ::= expr_log_or:val {: RESULT = val; :};

expr_log_or ::= expr_log_or OR expr_log_and
              {: RESULT = true; :} 
              | expr_log_and:val {: RESULT = val; :}
              ;

expr_log_and ::= expr_log_and AND expr_rel
               {: RESULT = true; :}
               | expr_rel:val {: RESULT = val; :}
               ;

expr_rel ::=
      expr_aditiva:val1 op_rel:op expr_aditiva:val2
      {:
          String op1 = (String) val1;
          String op2 = (String) val2;
          String oprel = (String) op;

          // crear temporal booleano
          MySymbol tmp = createTempFor("bool");
          String t = tmp.getAddress();

          codigoIntermedio.add(oprel, op1, op2, t);
          RESULT = t;
      :}
    | expr_aditiva:val {: RESULT = val; :}
    ;

op_rel ::= 
      LT   {: RESULT = "<"; :}
    | LE   {: RESULT = "<="; :}
    | GT   {: RESULT = ">"; :}
    | GE   {: RESULT = ">="; :}
    | EQ   {: RESULT = "=="; :}
    | NE   {: RESULT = "!="; :}
    ;

expr_aditiva ::=
      expr_aditiva:e1 PLUS expr_mult:e2
        {:
            String op1 = (String) e1;
            String op2 = (String) e2;
            // inferir tipo para el temporal
            String tipo = inferTypeOfOperand(op1);
            if (tipo.equals("int") == false) tipo = inferTypeOfOperand(op2); 
            MySymbol tmpSym = createTempFor(tipo);
            String tname = tmpSym.getAddress();
            codigoIntermedio.add("+", op1, op2, tname);
            RESULT = tname;
        :}
    | expr_aditiva:e1 MINUS expr_mult:e2
        {:
            String op1 = (String) e1;
            String op2 = (String) e2;
            String tipo = inferTypeOfOperand(op1);
            MySymbol tmpSym = createTempFor(tipo);
            String tname = tmpSym.getAddress();
            codigoIntermedio.add("-", op1, op2, tname);
            RESULT = tname;
        :}
    | expr_mult:val {: RESULT = val; :}
    ;

expr_mult ::= expr_mult MULT expr_pot
            {: RESULT = null; :}
            | expr_mult DIV expr_pot
            {: RESULT = null; :}
            | expr_mult INT_DIV expr_pot
            {: RESULT = null; :}
            | expr_mult MOD expr_pot
            {: RESULT = null; :}
            | expr_pot:val {: RESULT = val; :}
            ;

expr_pot ::= expr_unaria:val {: RESULT = val; :};

expr_unaria ::= op_unario expr_unaria {: RESULT = null; :}
              | expr_postfijo:val {: RESULT = val; :}
              ;

op_unario ::= SIGMA | MINUS;

expr_postfijo ::= primario:val {: RESULT = val; :};

postfix_op ::= INCREMENT | DECREMENT | OPEN_BRACKET expr CLOSE_BRACKET ;

primario ::=
      lit:val
        {: RESULT = val; :}
    | IDENTIFIER:id
        {:
            // devolver el nombre de la variable directamente
            RESULT = (String) id;
        :}
    | llamada_func
        {: RESULT = null; :}
    | OPEN_PAREN expr:val CLOSE_PAREN
        {: RESULT = val; :}
    ;

llamada_func ::= 
      IDENTIFIER OPEN_PAREN lista_args_opt CLOSE_PAREN
    ;

lista_args_opt ::= /* vacío */ | lista_args ;

lista_args ::=  lista_args  COMMA expr | expr ;

cond_bool ::=
    expr:val
    {:
        if (val == null) {
            RESULT = "true"; // fallback: por defecto
        } else {
            RESULT = val.toString();
        }
    :};


/* ===================== LITERALES ===================== */

lit ::=
      INTEGER_LITERAL:val     {: RESULT = val; :}
    | FLOAT_LITERAL:val       {: RESULT = val; :}
    | TRUE                    {: RESULT = true; :}
    | FALSE                   {: RESULT = false; :}
    | CHAR_LITERAL:val        {: RESULT = "'" + val + "'"; :} 
    | STRING_LITERAL:val      {: RESULT = "'" + val + "'"; :} 
    | lit_arreglo:val         {: RESULT = val; :}
    ;

lit_arreglo ::= OPEN_BRACE lista_elem_arr_opt CLOSE_BRACE ;

lista_elem_arr_opt ::= /* vacío */| lista_elem_arr ;

lista_elem_arr ::= lista_elem_arr COMMA expr | expr;

/* Recuperación de errores */

sentencia ::= error SEMICOLON
    {: 
        System.err.println("Recuperado de error: se omite hasta '$'");
    :};

decl ::= error SEMICOLON
    {: 
        System.err.println("Declaración inválida ignorada hasta '$'");
    :};