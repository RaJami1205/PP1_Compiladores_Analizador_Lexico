package ParserLexer;
import java_cup.runtime.*;
import Compilador.SymbolTable;

parser code {:
    
    Lexer lex;
    public static java.util.List<String> errores = new java.util.ArrayList<>();
    public static SymbolTable tablaSimbolos = new SymbolTable();

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    @Override
    public void report_error(String message, Object info) {
        errores.add("Error sintáctico: " + message + " en " + info);
        System.err.println("Error sintáctico: " + message + " en " + info);
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        errores.add("Token inesperado '" + cur_token.value + 
                    "' en línea " + (cur_token.left+1) + 
                    ", columna " + (cur_token.right+1));
        System.err.println("Token inesperado '" + cur_token.value + 
                           "' en línea " + (cur_token.left+1) + 
                           ", columna " + (cur_token.right+1));
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        errores.add("Error no recuperable: " + cur_token.value);
        System.err.println("Error no recuperable: " + cur_token.value);
    }
:}

init with {: :};

 scan with {: return lex.next_token(); :}

/* Definición de los terminales */

terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Float FLOAT_LITERAL;
terminal Character CHAR_LITERAL;
terminal String STRING_LITERAL;
terminal Boolean TRUE, FALSE;

terminal String INT, FLOAT, CHAR, BOOL, STRING;

terminal 
    LET, PROCEDURE, PRINCIPAL,
    DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, STEP, TO, DOWNTO, DO,
    RETURN, BREAK, INPUT, OUTPUT,
    ASSIGN, LT, LE, GT, GE, EQ, NE, PLUS, MINUS, MULT, DIV, INT_DIV, MOD, POW,
    AND, OR, SIGMA, INCREMENT, DECREMENT,
    OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
    OPEN_BRACKET, CLOSE_BRACKET, COLON, COMMA, ARROW, SEMICOLON, COMMENT_LINE, COMMENT_MULTI;


/* Definición de los no terminales */
non terminal 
    programa, decl_glob, decl_var, funcion, principal, 
    param_formales_opt, lista_params, param, tipo_ret, tipo, tipo_arreglo, tam_arreglo,
    bloque, sentencia, sent_decl_local, sent_asig_o_expr, sent_decide, sent_loop, sent_for,
    sent_return, sent_break, sent_io, comentario, comentario_linea, comentario_multilinea,
    init_opt, asignacion, lvalue, expr_sin_asignacion, lista_out, expr,
    expr_log_or, expr_log_and, expr_rel, op_rel, expr_aditiva, expr_mult, expr_pot, expr_unaria,
    op_unario, expr_postfijo, postfix_op, primario, llamada_func, lista_args_opt, lista_args,
    cond_bool, lit, lista_elem_arr_opt, lista_elem_arr, valor_step,sent_loop_rec,for_dir,sent_decide_rec,
    lit_arreglo,lista_decl,decl,lista_sentencias_opt,lista_sentencias,decl_var_simple,decl_var_arreglo,
    init_arr_opt,lvalue_aux;

precedence left OR;
precedence left AND;
precedence nonassoc LT, LE, GT, GE, EQ, NE;
precedence left PLUS, MINUS;
precedence left MULT, DIV, INT_DIV, MOD;
precedence right POW;
precedence right SIGMA; 



start with programa;

programa ::= lista_decl;

lista_decl ::= lista_decl decl | decl;

decl ::= decl_glob | funcion | principal ; 

decl_glob ::= LET decl_var SEMICOLON ;

principal ::= PROCEDURE PRINCIPAL OPEN_PAREN CLOSE_PAREN  
    {: 
        if (!tablaSimbolos.addSymbol("principal", "void", "procedure", null)) {
                System.err.println("Error: El procedimiento principal ya esta declarado.");
        } else {
                System.out.println("Procedimiento principal agregado a la tabla de símbolos (tipo void).");
        }

        System.out.println(">> Entrando a ámbito del procedimiento principal");

    :}
    bloque
    {:
        System.out.println("<< Saliendo del ámbito del procedimiento principal");
    :};
 
funcion ::=
    tipo_ret:ret IDENTIFIER:id
    {:
        String nombre = (String) id;  
        String tipoRet = (String) ret;

        if (!tablaSimbolos.addSymbol(nombre, tipoRet, "function", null)) {
            System.err.println("Error semántico: función duplicada " + nombre);
        } else {
            Compilador.Symbol s = tablaSimbolos.getSymbol(nombre);
            s.setReturnType(tipoRet);
            System.out.println("Función agregada: " + s);
        }

        System.out.println(">> Entrando a ámbito de función " + nombre);
    :}
    OPEN_PAREN param_formales_opt CLOSE_PAREN
    bloque
    {:
        System.out.println("<< Saliendo de ámbito de función " + id);
    :};
            
param_formales_opt ::= /* vacío */ | lista_params ; 

lista_params ::= lista_params COMMA param | param;

param ::= IDENTIFIER:id COLON tipo:tipoParam
        {:
            if(!tablaSimbolos.addSymbol((String)id,(String)tipoParam,"param",null))
            {
                System.out.println("YA EXISTE PARAMETRO CON ESE NOMBRE");
        
            };
        :}
 ;

tipo_ret ::= INT   {: RESULT = "int"; :}
            | FLOAT {: RESULT = "float"; :}
            | CHAR  {: RESULT = "char"; :}
            | BOOL  {: RESULT = "bool"; :}
            | STRING {: RESULT = "string"; :}
            ;

tipo ::= INT   {: RESULT = "int"; :}
       | FLOAT {: RESULT = "float"; :}
       | CHAR  {: RESULT = "char"; :}
       | BOOL  {: RESULT = "bool"; :}
       | STRING {: RESULT = "string"; :}
       | tipo_arreglo {: RESULT = "array"; :}
       ;

tipo_arreglo ::= INT OPEN_BRACKET tam_arreglo CLOSE_BRACKET {: RESULT = "int[]"; :}
               | CHAR OPEN_BRACKET tam_arreglo CLOSE_BRACKET {: RESULT = "char[]"; :}
               ;

tam_arreglo ::= INTEGER_LITERAL ;

/* ===================== BLOQUES Y SENTENCIAS ===================== */


bloque ::=
    OPEN_BRACE
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a nuevo ámbito (bloque)");
    :}
    lista_sentencias_opt
    CLOSE_BRACE
    {:
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ámbito (bloque)");
    :};

lista_sentencias_opt ::= /* vacío */ | lista_sentencias ;

lista_sentencias ::= lista_sentencias sentencia | sentencia ; // evitar ambiguedades 

sentencia ::= sent_decl_local
            | sent_asig_o_expr
            | sent_decide
            | sent_loop
            | sent_for
            | sent_return
            | sent_break
            | sent_io
            | comentario 
            ;

comentario ::= comentario_linea| comentario_multilinea ;

comentario_linea ::= COMMENT_LINE ; 
comentario_multilinea ::= COMMENT_MULTI ;

sent_decl_local ::= LET decl_var SEMICOLON;

decl_var ::= decl_var_simple | decl_var_arreglo;

decl_var_simple ::= tipo:tipo IDENTIFIER:id init_opt:valorInit {:
    String nombre = (String) id;       
    String tipoVar = (String) tipo;    
    Object valor = valorInit;

    if (!tablaSimbolos.addSymbol(nombre, tipoVar, "variable", valor)) {
        System.err.println("Error semántico: variable " + nombre + " ya declarada.");
    } else {
        Compilador.Symbol s = tablaSimbolos.getSymbol((String) id);
        s.setAddress(nombre);  
        s.setOffset(0);       
        System.out.println("Variable agregada: " + s);
    }
:};

decl_var_arreglo ::= IDENTIFIER COLON tipo_arreglo init_arr_opt ;

init_opt ::=
    /* vacío */ 
        {: RESULT = null; :}
  | ASSIGN expr:valor
        {: RESULT = valor; :};

init_arr_opt ::=   /*vacio*/ |ASSIGN lit_arreglo;
 

asignacion ::= IDENTIFIER:id ASSIGN expr:valor {:
    boolean ok = tablaSimbolos.updateValue((String)id, valor);
    if (!ok) {
        System.err.println("Error: variable " + id + " no declarada.");
    } else {
        System.out.println("Asignación: " + id + " = " + valor);
    }
:};


lvalue ::= IDENTIFIER lvalue_aux;

lvalue_aux::= /*vacio*/ | IDENTIFIER OPEN_BRACKET expr CLOSE_BRACKET;


expr_sin_asignacion ::= expr ;

sent_asig_o_expr ::= asignacion SEMICOLON
                  | expr_sin_asignacion SEMICOLON;

/* ===================== ESTRUCTURAS DE CONTROL ====================*/

sent_decide ::= 
    DECIDE OF OPEN_PAREN cond_bool CLOSE_PAREN ARROW
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ambito DECIDE");
    :}
    bloque sent_decide_rec 
    END DECIDE SEMICOLON
    {:
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ambito DECIDE");
    :};


sent_decide_rec ::=
      OPEN_PAREN cond_bool CLOSE_PAREN ARROW bloque sent_decide_rec
    | ELSE ARROW bloque
    | /* vacío */
    ;


sent_loop ::= 
    LOOP
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ambito LOOP");
    :}
    sent_loop_rec EXIT WHEN cond_bool SEMICOLON END LOOP SEMICOLON
    {:
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ambito LOOP");
    :};


sent_loop_rec ::= sentencia sent_loop_rec | /* vacío */ ;

sent_for ::= 
    FOR 
    {:
        tablaSimbolos.enterScope();
        System.out.println(">> Entrando a ambito FOR");
    :}
    asignacion STEP valor_step for_dir expr DO bloque
    {:
        tablaSimbolos.exitScope();
        System.out.println("<< Saliendo de ambito FOR");
    :};


for_dir ::= TO | DOWNTO ;

valor_step ::= INTEGER_LITERAL | FLOAT_LITERAL ;

/* ===================== RETURN / BREAK ===================== */

sent_return ::= RETURN expr SEMICOLON| RETURN SEMICOLON ;

sent_break ::= BREAK SEMICOLON ;

/* ===================== I/O ===================== */

sent_io ::= INPUT OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON
          | OUTPUT OPEN_PAREN lista_out CLOSE_PAREN SEMICOLON
          ;

lista_out ::= lista_out COMMA expr | expr;

/* ===================== EXPRESIONES ===================== */

expr ::= expr_log_or:val {: RESULT = val; :};

expr_log_or ::= expr_log_or OR expr_log_and
              {: RESULT = true; :} // simplificado: no se evalúa aún, pero no es null
              | expr_log_and:val {: RESULT = val; :}
              ;

expr_log_and ::= expr_log_and AND expr_rel
               {: RESULT = true; :}
               | expr_rel:val {: RESULT = val; :}
               ;

expr_rel ::= expr_aditiva:val1 op_rel expr_aditiva:val2
           {: RESULT = true; :} // igual: no evaluamos aún, pero evita null
           | expr_aditiva:val {: RESULT = val; :}
           ;

expr_aditiva ::= expr_aditiva PLUS expr_mult
               {: RESULT = null; :}
               | expr_aditiva MINUS expr_mult
               {: RESULT = null; :}
               | expr_mult:val {: RESULT = val; :}
               ;

expr_mult ::= expr_mult MULT expr_pot
            {: RESULT = null; :}
            | expr_mult DIV expr_pot
            {: RESULT = null; :}
            | expr_mult INT_DIV expr_pot
            {: RESULT = null; :}
            | expr_mult MOD expr_pot
            {: RESULT = null; :}
            | expr_pot:val {: RESULT = val; :}
            ;

expr_pot ::= expr_unaria:val {: RESULT = val; :};

expr_unaria ::= op_unario expr_unaria {: RESULT = null; :}
              | expr_postfijo:val {: RESULT = val; :}
              ;

expr_postfijo ::= primario:val {: RESULT = val; :};

primario ::= lit:val {: RESULT = val; :}
           | lvalue {: RESULT = null; :}
           | llamada_func {: RESULT = null; :}
           | OPEN_PAREN expr:val CLOSE_PAREN {: RESULT = val; :}
           ;

llamada_func ::= 
      IDENTIFIER OPEN_PAREN lista_args_opt CLOSE_PAREN
    ;

lista_args_opt ::= /* vacío */ | lista_args ;

lista_args ::=  lista_args  COMMA expr | expr ;

cond_bool ::= expr ;


/* ===================== LITERALES ===================== */

lit ::=
      INTEGER_LITERAL:val     {: RESULT = val; :}
    | FLOAT_LITERAL:val       {: RESULT = val; :}
    | TRUE                    {: RESULT = true; :}
    | FALSE                   {: RESULT = false; :}
    | CHAR_LITERAL:val        {: RESULT = val; :}
    | STRING_LITERAL:val      {: RESULT = val; :}
    | lit_arreglo:val         {: RESULT = val; :}
    ;

lit_arreglo ::= OPEN_BRACE lista_elem_arr_opt CLOSE_BRACE ;

lista_elem_arr_opt ::= /* vacío */| lista_elem_arr ;

lista_elem_arr ::= lista_elem_arr COMMA expr | expr;

/* Recuperación de errores */

sentencia ::= error SEMICOLON
    {: 
        System.err.println("Recuperado de error: se omite hasta '$'");
    :};

decl ::= error SEMICOLON
    {: 
        System.err.println("Declaración inválida ignorada hasta '$'");
    :};