package ParserLexer;
import java_cup.runtime.*;
 action code {:
 
    public void hola(){
        System.out.println("hola.");
    }
 
    public void adios(){
        System.out.println("adios");
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

:}
 
init with {: :};

 scan with {: return lex.next_token(); :}

/* Definición de los terminales */
terminal 
    LET, PROCEDURE, PRINCIPAL, FUNCTION, INT, FLOAT, CHAR, BOOL, TRUE, FALSE,
    DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, STEP, TO, DOWNTO, DO,
    RETURN, BREAK, INPUT, OUTPUT,
    ASSIGN, LT, LE, GT, GE, EQ, NE, PLUS, MINUS, MULT, DIV, INT_DIV, MOD, POW,
    AND, OR, SIGMA, INCREMENT, DECREMENT,
    OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
    OPEN_BRACKET, CLOSE_BRACKET, COLON, COMMA, ARROW, SEMICOLON,
    INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL, IDENTIFIER, COMMENT_LINE, COMMENT_MULTI;


/* Definición de los no terminales */
non terminal 
    programa, decl_glob, decl_var, funcion, principal, 
    param_formales_opt, lista_params, param, tipo_ret, tipo, tipo_arreglo, tam_arreglo,
    bloque, sentencia, sent_decl_local, sent_asig_o_expr, sent_decide, sent_loop, sent_for,
    sent_return, sent_break, sent_io, comentario, comentario_linea, comentario_multilinea,
    init_opt, init_arr_opt, asignacion, lvalue, expr_sin_asignacion, lista_out, expr,
    expr_log_or, expr_log_and, expr_rel, op_rel, expr_aditiva, expr_mult, expr_pot, expr_unaria,
    op_unario, expr_postfijo, postfix_op, primario, llamada_func, lista_args_opt, lista_args,
    cond_bool, lit, lista_elem_arr_opt, lista_elem_arr, valor_step,sent_loop_rec,for_dir,sent_decide_rec,
    lit_arreglo,lista_decl,decl,lista_sentencias_opt,lista_sentencias, lista_params_opt;


// PROGRAMA

precedence left OR;
precedence left AND;
precedence nonassoc LT LE GT GE EQ NE;
precedence left PLUS MINUS;
precedence left MULT DIV INT_DIV MOD;
precedence right POW;
precedence right SIGMA MINUS; // unarios




start with programa;

programa ::= lista_decl;

lista_decl ::= lista_decl decl | decl;

decl ::= decl_glob | funcion | principal ; // para evitar ambiguedades

decl_glob ::= LET decl_var SEMICOLON ;

principal ::= PROCEDURE PRINCIPAL OPEN_PAREN CLOSE_PAREN bloque ;
 
funcion ::= FUNCTION IDENTIFIER OPEN_PAREN param_formales_opt CLOSE_PAREN COLON tipo_ret bloque ;
            
param_formales_opt ::= /* vacío */ | lista_params ; 

lista_params_opt ::= /* vacío */ | lista_params ;

lista_params ::= lista_params COMMA param | param;

param ::= IDENTIFIER COLON tipo ;

tipo_ret ::=  INT | FLOAT | CHAR | BOOL ;

tipo ::= INT | FLOAT | CHAR | BOOL | tipo_arreglo ;

tipo_arreglo ::= INT OPEN_BRACKET tam_arreglo CLOSE_BRACKET | CHAR OPEN_BRACKET tam_arreglo CLOSE_BRACKET ;

tam_arreglo ::= INTEGER_LITERAL ;

/* ===================== BLOQUES Y SENTENCIAS ===================== */


bloque ::= OPEN_BRACE lista_sentencias_opt CLOSE_BRACE ;

lista_sentencias_opt ::= /* vacío */ | lista_sentencias ;

lista_sentencias ::= lista_sentencias sentencia | sentencia ; // evitar ambiguedades 

sentencia ::= sent_decl_local
            | sent_asig_o_expr
            | sent_decide
            | sent_loop
            | sent_for
            | sent_return
            | sent_break
            | sent_io
            | comentario 
            ;

comentario ::= comentario_linea| comentario_multilinea ;

comentario_linea ::= COMMENT_LINE ; // REVISAR COMMENTS
comentario_multilinea ::= COMMENT_MULTI ;

sent_decl_local ::= LET decl_var SEMICOLON ;

decl_var ::= IDENTIFIER COLON tipo init_opt | IDENTIFIER COLON tipo_arreglo init_arr_opt ;

init_opt ::= /* vacío */ | ASSIGN expr ;

init_arr_opt ::= /* vacío */ | ASSIGN lit_arreglo ;

asignacion ::= lvalue ASSIGN expr ;

lvalue ::= IDENTIFIER 
        | IDENTIFIER OPEN_BRACKET expr CLOSE_BRACKET ;

expr_sin_asignacion ::= expr ;

sent_asig_o_expr ::= asignacion SEMICOLON
                  | expr_sin_asignacion SEMICOLON
                  ;

/* ===================== ESTRUCTURAS DE CONTROL ====================*/

sent_decide ::= DECIDE OF OPEN_PAREN cond_bool CLOSE_PAREN ARROW bloque sent_decide_rec END DECIDE SEMICOLON ;

sent_decide_rec ::=
      OPEN_PAREN cond_bool CLOSE_PAREN ARROW bloque sent_decide_rec
    | ELSE ARROW bloque
    | /* vacío */
    ;

sent_loop ::= LOOP sent_loop_rec EXIT WHEN cond_bool SEMICOLON END LOOP SEMICOLON ;

sent_loop_rec ::= sentencia sent_loop_rec | /* vacío */ ;

sent_for ::= FOR asignacion STEP valor_step for_dir expr DO bloque ;

for_dir ::= TO | DOWNTO ;

valor_step ::= INTEGER_LITERAL | FLOAT_LITERAL ;

/* ===================== RETURN / BREAK ===================== */

sent_return ::= RETURN expr SEMICOLON| RETURN SEMICOLON ;

sent_break ::= BREAK SEMICOLON ;

/* ===================== I/O ===================== */

sent_io ::= INPUT OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON
          | OUTPUT OPEN_PAREN lista_out CLOSE_PAREN SEMICOLON
          ;

lista_out ::= lista_out COMMA expr | expr;

/* ===================== EXPRESIONES ===================== */

expr ::= expr_log_or ;

expr_log_or ::= expr_log_or OR expr_log_and
              | expr_log_and
              ;

expr_log_and ::= expr_log_and AND expr_rel
               | expr_rel
               ;

expr_rel ::= expr_aditiva op_rel expr_aditiva
           | expr_aditiva
           ;

op_rel ::= LT | LE | GT | GE | EQ | NE ;

expr_aditiva ::= expr_aditiva PLUS expr_mult
               | expr_aditiva MINUS expr_mult
               | expr_mult
               ;

expr_mult ::= expr_mult MULT expr_pot
            | expr_mult DIV expr_pot
            | expr_mult INT_DIV expr_pot
            | expr_mult MOD expr_pot
            | expr_pot
            ;

expr_pot ::= expr_unaria POW expr_pot
           | expr_unaria
           ;

expr_unaria ::= op_unario expr_unaria
              | expr_postfijo
              ;

op_unario ::= MINUS | SIGMA ;

expr_postfijo ::= expr_postfijo postfix_op
                | primario
                ;

postfix_op ::= INCREMENT
             | DECREMENT
             | OPEN_BRACKET expr CLOSE_BRACKET
             ;

primario ::= lit
           | lvalue
           | llamada_func
           | OPEN_PAREN expr CLOSE_PAREN
           ;

llamada_func ::= 
      IDENTIFIER OPEN_PAREN lista_args_opt CLOSE_PAREN
    ;

lista_args_opt ::= /* vacío */ | lista_args ;

lista_args ::=  lista_args  COMMA expr | expr ;

cond_bool ::= expr ;


/* ===================== LITERALES ===================== */

lit ::= INTEGER_LITERAL
      | FLOAT_LITERAL
      | TRUE
      | FALSE
      | CHAR_LITERAL
      | STRING_LITERAL              
      | OPEN_BRACE lista_elem_arr_opt CLOSE_BRACE
      ;


lista_elem_arr_opt ::= /* vacío */| lista_elem_arr ;

lista_elem_arr ::= lista_elem_arr COMMA expr | expr;
