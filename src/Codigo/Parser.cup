package ParserLexer;
import java_cup.runtime.*;
 action code {:
 
    public void hola(){
        System.out.println("hola.");
    }
 
    public void adios(){
        System.out.println("adios");
    }
:}
 
parser code {:
    BasicLexerCup lex;
   
    @SuppressWarnings("deprecation")
    public parser(BasicLexerCup lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

:}
 
init with {: :};

 scan with {: return lex.next_token(); :}

/* Definición de los terminales */
terminal 
    LET, PROCEDURE, PRINCIPAL, FUNCTION, INT, FLOAT, CHAR, BOOL, TRUE, FALSE,
    DECIDE, OF, ELSE, END, LOOP, EXIT, WHEN, FOR, STEP, TO, DOWNTO, DO,
    RETURN, BREAK, INPUT, OUTPUT,
    ASSIGN, LT, LE, GT, GE, EQ, NE, PLUS, MINUS, MULT, DIV, INT_DIV, MOD, POW,
    AND, OR, SIGMA, INCREMENT, DECREMENT,
    OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
    OPEN_BRACKET, CLOSE_BRACKET, COLON, COMMA, ARROW, SEMICOLON,
    INTEGER_LITERAL, FLOAT_LITERAL, CHAR_LITERAL, STRING_LITERAL, IDENTIFIER;


/* Definición de los no terminales */
non terminal 
    programa, decl_glob, decl_var, funcion, principal, 
    param_formales_opt, lista_params, param, tipo_ret, tipo, tipo_arreglo, tam_arreglo,
    bloque, sentencia, sent_decl_local, sent_asig_o_expr, sent_decide, sent_loop, sent_for,
    sent_return, sent_break, sent_io, comentario, comentario_linea, comentario_multilinea,
    init_opt, init_arr_opt, asignacion, lvalue, expr_sin_asignacion, lista_out, expr,
    expr_log_or, expr_log_and, expr_rel, op_rel, expr_aditiva, expr_mult, expr_pot, expr_unaria,
    op_unario, expr_postfijo, postfix_op, primario, llamada_func, lista_args_opt, lista_args,
    cond_bool, lit, lista_elem_arr_opt, lista_elem_arr, signo_opt, valor_step,sent_loop_rec,for_dir,sent_decide_rec;


// PROGRAMA

start with programa;

programa::= decl_glob programa | funcion programa | principal;

decl_glob ::= LET decl_var SEMICOLON ;

principal::= PROCEDURE PRINCIPAL OPEN_PAREN CLOSE_PAREN bloque ;
 
funcion ::= FUNCTION IDENTIFIER OPEN_PAREN param_formales_opt CLOSE_PAREN COLON tipo_ret bloque ;
            
param_formales_opt ::= /* vacío */ | lista_params; 

lista_params ::= param | param  COMMA lista_params 

param ::= IDENTIFIER COLON tipo ;

tipo_ret ::=  INT | FLOAT | CHAR | BOOL ;

tipo ::= INT | FLOAT | CHAR | BOOL | tipo_arreglo;

tipo_arreglo ::= INT OPEN_BRACKET tam_arreglo CLOSE_BRACKET | CHAR OPEN_BRACKET tam_arreglo CLOSE_BRACKET ;

tam_arreglo ::= INTEGER_LITERAL ;

/* ===================== BLOQUES Y SENTENCIAS ===================== */


bloque ::= OPEN_BRACE CLOSE_BRACE | OPEN_BRACE sentencia bloque CLOSE_BRACE | sentencia ;

sentencia ::= sent_decl_local
            | sent_asig_o_expr
            | sent_decide
            | sent_loop
            | sent_for
            | sent_return
            | sent_break
            | sent_io
            | comentario 
            ;

comentario ::= comentario_linea| comentario_multilinea ;

comentario_linea ::= COMMENT_LINE ; // REVISAR COMMENTS
comentario_multilinea ::= COMMENT_MULTI ;

sent_decl_local ::= LET decl_var SEMICOLON ;

decl_var ::= IDENTIFIER COLON tipo init_opt | IDENTIFIER COLON tipo_arreglo init_arr_opt ;

init_opt ::= /* vacío */ | ASSIGN expr ;

init_arr_opt ::= /* vacío */ | ASSIGN lit_arreglo ;

asignacion ::= lvalue ASSIGN expr ;

lvalue ::= IDENTIFIER 
        | IDENTIFIER OPEN_BRACKET expr CLOSE_BRACKET ;

expr_sin_asignacion ::= expr ;

sent_asig_o_expr ::= asignacion SEMICOLON
                  | expr_sin_asignacion SEMICOLON
                  ;

/* ===================== ESTRUCTURAS DE CONTROL ====================*/

sent_decide ::= DECIDE OF OPEN_PAREN cond_bool CLOSE_PAREN ARROW bloque sent_decide_rec END DECIDE SEMICOLON ;

sent_decide_rec ::=
      OPEN_PAREN cond_bool CLOSE_PAREN ARROW bloque sent_decide_rec
    | ELSE ARROW bloque
    | /* vacío */
    ;

sent_loop ::= LOOP sent_loop_rec EXIT WHEN cond_bool SEMICOLON END LOOP SEMICOLON ;

sent_loop_rec ::= sentencia sent_loop_rec | /* vacío */ ;

sent_for ::=FOR asignacion STEP valor_step for_dir expr DO bloque ;

for_dir ::= TO | DOWNTO ;

valor_step ::= INTEGER_LITERAL | FLOAT_LITERAL ;

/* ===================== RETURN / BREAK ===================== */

sent_return ::= RETURN expr SEMICOLON| RETURN SEMICOLON;

sent_break ::= BREAK SEMICOLON ;

/* ===================== I/O ===================== */

sent_io ::= INPUT OPEN_PAREN IDENTIFIER CLOSE_PAREN SEMICOLON
          | OUTPUT OPEN_PAREN lista_out CLOSE_PAREN SEMICOLON
          ;

lista_out ::= expr | expr COMMA lista_out ;

/* ===================== EXPRESIONES ===================== */

expr ::= expr_log_or ;

expr_log_or ::= expr_log_and | expr_log_and OR expr_log_or ;

expr_log_and ::= expr_rel | expr_rel AND expr_log_and ;

expr_rel ::= expr_aditiva | expr_aditiva op_rel expr_aditiva ;

op_rel ::=
      LT
    | LE
    | GT
    | GE
    | EQ
    | NE
    ;

expr_aditiva ::=
      expr_mult
    | expr_mult PLUS expr_aditiva
    | expr_mult MINUS expr_aditiva
    ;

expr_mult ::=
      expr_pot
    | expr_pot MULT expr_mult
    | expr_pot DIV expr_mult
    | expr_pot INT_DIV expr_mult
    | expr_pot MOD expr_mult
    ;

expr_pot ::= expr_unaria | expr_unaria POW expr_pot ;

expr_unaria ::= op_unario expr_unaria | expr_postfijo ;

op_unario ::=
      MINUS
    | SIGMA
    ;

expr_postfijo ::=
      primario
    | primario postfix_op
    | primario postfix_op expr_postfijo
    ;

postfix_op ::=
      INCREMENT
    | DECREMENT
    | OPEN_BRACKET expr CLOSE_BRACKET
    ;

primario ::=
      lit
    | lvalue
    | llamada_func
    | OPEN_PAREN expr CLOSE_PAREN
    ;

llamada_func ::=
      IDENTIFIER OPEN_PAREN lista_args_opt CLOSE_PAREN
    ;

lista_args_opt ::= /* vacío */ | lista_args ;

lista_args ::= expr | expr COMMA lista_args ;

cond_bool ::= expr ;


/* ===================== LITERALES ===================== */

lit ::= INTEGER_LITERAL
      | FLOAT_LITERAL
      | TRUE
      | FALSE
      | CHAR_LITERAL
      | STRING_LITERAL
      | OPEN_BRACE lista_elem_arr_opt CLOSE_BRACE
      ;


lista_elem_arr_opt ::= /* vacío */
                     | lista_elem_arr
                     ;

lista_elem_arr ::= expr
                 | expr COMMA lista_elem_arr
                 ;

